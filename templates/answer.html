<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complex Test Page</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #1a1a1a; color: #e0e0e0; margin: 0; padding: 20px; }
        .container { max-width: 1000px; margin: 0 auto; }
        .card { background: #2d2d2d; border-radius: 8px; padding: 20px; margin-bottom: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.3); }
        h1, h2 { color: #4CAF50; }
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        canvas { background: #fff; border-radius: 4px; display: block; width: 100%; height: 300px; }
        .code-block { background: #000; padding: 15px; border-radius: 4px; overflow-x: auto; font-family: 'Courier New', Courier, monospace; }
        .status-badge { display: inline-block; padding: 5px 10px; border-radius: 20px; background: #4CAF50; color: white; font-size: 0.8em; }
        
        /* New styles for Sandbox */
        #sandbox-container { position: relative; width: 100%; height: 300px; background: #fff; border-radius: 4px; overflow: hidden; }
        #sandboxCanvas { width: 100%; height: 100%; display: block; background: #f0f0f0; }
        .overlay { position: absolute; top: 10px; left: 10px; background: rgba(0, 0, 0, 0.7); color: #fff; padding: 10px; border-radius: 4px; font-family: monospace; pointer-events: none; }
        .controls { margin-top: 10px; }
        .toggle-btn { background: #4CAF50; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 14px; }
        .toggle-btn:hover { background: #45a049; }
        .toggle-btn.active { background: #d32f2f; }
    </style>
</head>
<body>
    <div class="container">
        <h1>AI Coding Ability Test Dashboard</h1>
        <p>Server Time: {{ server_time }} <span class="status-badge">Live</span></p>

        <div class="grid">
            <div class="card">
                <h2>Live Physics Sandbox</h2>
                <div id="sandbox-container">
                    <canvas id="sandboxCanvas"></canvas>
                    <div class="overlay" id="perfMonitor">
                        FPS: <span id="fpsDisplay">0</span><br>
                        Worker Latency: <span id="latencyDisplay">0</span>ms<br>
                        Particles: <span id="countDisplay">50</span>
                    </div>
                </div>
                <div class="controls">
                    <button id="chaosToggle" class="toggle-btn">Chaos Mode: OFF</button>
                </div>
            </div>
            <div class="card">
                <h2>Recursive Data Processing</h2>
                <p>Fibonacci Sequence (Server-side Computed):</p>
                <div class="code-block">
                    {{ fib_sequence | join(', ') }}
                </div>
                <p style="margin-top: 20px;">Matrix Multiplication (Client-side):</p>
                <div id="matrixResult" class="code-block"></div>
            </div>
        </div>

        <div class="card">
            <h2>Dynamic Data Table</h2>
            <div style="max-height: 300px; overflow-y: auto;">
                <table style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr style="text-align: left; border-bottom: 1px solid #444;">
                            <th>Index</th>
                            <th>X-Value</th>
                            <th>Y-Value (Computed)</th>
                        </tr>
                    </thead>
                    <tbody>
                        {% for pt in data_points %}
                        <tr style="border-bottom: 1px solid #333;">
                            <td>{{ loop.index }}</td>
                            <td>{{ pt.x }}</td>
                            <td>{{ pt.y }}</td>
                        </tr>
                        {% endfor %}
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script id="data-points-data" type="application/json">
        {{ data_points | tojson | safe }}
    </script>

    <script>
        // Web Worker Logic as a Blob
        const workerCode = `
            let particles = [];
            let width = 0;
            let height = 0;
            let gravity = 0.5;

            function initParticles(count, w, h) {
                width = w;
                height = h;
                particles = [];
                for (let i = 0; i < count; i++) {
                    particles.push({
                        x: Math.random() * width,
                        y: Math.random() * height,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10,
                        radius: Math.random() * 10 + 5,
                        color: \`hsl(\${Math.random() * 360}, 70%, 50%)\`,
                        mass: Math.random() * 10 + 5
                    });
                }
            }

            function resolveCollision(p1, p2) {
                const dx = p1.x - p2.x;
                const dy = p1.y - p2.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < p1.radius + p2.radius) {
                    // Elastic collision
                    const nx = dx / distance;
                    const ny = dy / distance;
                    const p = 2 * (p1.vx * nx + p1.vy * ny - p2.vx * nx - p2.vy * ny) / (p1.mass + p2.mass);
                    
                    p1.vx -= p * p2.mass * nx;
                    p1.vy -= p * p2.mass * ny;
                    p2.vx += p * p1.mass * nx;
                    p2.vy += p * p1.mass * ny;

                    // Separate particles to prevent sticking
                    const overlap = p1.radius + p2.radius - distance;
                    const separationX = overlap * nx * 0.5;
                    const separationY = overlap * ny * 0.5;
                    p1.x += separationX;
                    p1.y += separationY;
                    p2.x -= separationX;
                    p2.y -= separationY;
                }
            }

            self.onmessage = function(e) {
                const { type, payload } = e.data;
                const start = performance.now();

                if (type === 'INIT') {
                    initParticles(payload.count, payload.width, payload.height);
                } else if (type === 'UPDATE') {
                    // Physics Update
                    for (let i = 0; i < particles.length; i++) {
                        let p = particles[i];
                        
                        // Gravity
                        p.vy += gravity;
                        
                        // Move
                        p.x += p.vx;
                        p.y += p.vy;

                        // Wall collisions
                        if (p.x - p.radius < 0) {
                            p.x = p.radius;
                            p.vx *= -0.8;
                        } else if (p.x + p.radius > width) {
                            p.x = width - p.radius;
                            p.vx *= -0.8;
                        }
                        
                        if (p.y - p.radius < 0) {
                            p.y = p.radius;
                            p.vy *= -0.8;
                        } else if (p.y + p.radius > height) {
                            p.y = height - p.radius;
                            p.vy *= -0.8; // Dampening
                        }
                    }

                    // Particle collisions
                    for (let i = 0; i < particles.length; i++) {
                        for (let j = i + 1; j < particles.length; j++) {
                            resolveCollision(particles[i], particles[j]);
                        }
                    }

                    const end = performance.now();
                    self.postMessage({
                        type: 'UPDATE',
                        particles: particles,
                        latency: end - start
                    });
                }
            };
        `;

        const blob = new Blob([workerCode], { type: 'application/javascript' });
        const worker = new Worker(URL.createObjectURL(blob));

        // Canvas Setup
        const canvas = document.getElementById('sandboxCanvas');
        const ctx = canvas.getContext('2d');
        let width = canvas.width = canvas.parentElement.clientWidth;
        let height = canvas.height = canvas.parentElement.clientHeight;

        // Resize handler
        window.addEventListener('resize', () => {
            width = canvas.width = canvas.parentElement.clientWidth;
            height = canvas.height = canvas.parentElement.clientHeight;
            worker.postMessage({ type: 'INIT', payload: { count: isChaos ? 500 : 50, width, height } });
        });

        // State
        let isChaos = false;
        let lastTime = performance.now();
        let frameCount = 0;
        let lastFpsTime = lastTime;

        // UI Elements
        const fpsDisplay = document.getElementById('fpsDisplay');
        const latencyDisplay = document.getElementById('latencyDisplay');
        const countDisplay = document.getElementById('countDisplay');
        const chaosBtn = document.getElementById('chaosToggle');

        // Initial setup
        worker.postMessage({ type: 'INIT', payload: { count: 50, width, height } });

        // Physics Loop (Driven by RequestAnimationFrame to sync with Worker)
        function loop() {
            worker.postMessage({ type: 'UPDATE' });
        }

        worker.onmessage = function(e) {
            const { type, particles, latency } = e.data;
            if (type === 'UPDATE') {
                // Drawing
                ctx.clearRect(0, 0, width, height);
                for (const p of particles) {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                    ctx.fillStyle = p.color;
                    ctx.fill();
                    ctx.closePath();
                }

                // Stats
                const now = performance.now();
                frameCount++;
                if (now - lastFpsTime >= 1000) {
                    fpsDisplay.innerText = frameCount;
                    frameCount = 0;
                    lastFpsTime = now;
                }
                latencyDisplay.innerText = latency.toFixed(2);

                requestAnimationFrame(loop);
            }
        };

        // Start Loop
        loop();

        // Chaos Toggle
        chaosBtn.addEventListener('click', () => {
            isChaos = !isChaos;
            chaosBtn.classList.toggle('active');
            chaosBtn.innerText = isChaos ? 'Chaos Mode: ON' : 'Chaos Mode: OFF';
            const count = isChaos ? 500 : 50;
            countDisplay.innerText = count;
            worker.postMessage({ type: 'INIT', payload: { count, width, height } });
        });

        // Keep existing Matrix logic
        function multiplyMatrices(m1, m2) {
            const result = [];
            for (let i = 0; i < m1.length; i++) {
                result[i] = [];
                for (let j = 0; j < m2[0].length; j++) {
                    let sum = 0;
                    for (let k = 0; k < m1[0].length; k++) {
                        sum += m1[i][k] * m2[k][j];
                    }
                    result[i][j] = sum;
                }
            }
            return result;
        }

        const m1 = [[1, 2], [3, 4]];
        const m2 = [[5, 6], [7, 8]];
        const res = multiplyMatrices(m1, m2);
        document.getElementById('matrixResult').innerText = JSON.stringify(res);
    </script>
</body>
</html>
